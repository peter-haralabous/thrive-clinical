from http import HTTPStatus

import pytest
from django.contrib.contenttypes.models import ContentType
from django.http import HttpResponseRedirect
from django.test import Client
from django.urls import reverse

from sandwich.core.models.custom_attribute import CustomAttribute
from sandwich.core.models.custom_attribute import CustomAttributeEnum
from sandwich.core.models.custom_attribute import CustomAttributeValue
from sandwich.core.models.encounter import Encounter
from sandwich.core.models.organization import Organization
from sandwich.core.models.role import RoleName
from sandwich.core.service.organization_service import assign_organization_role
from sandwich.users.models import User


@pytest.mark.django_db
def test_attribute_edit_deny_access(user: User, organization: Organization) -> None:
    assign_organization_role(organization, RoleName.PATIENT, user)

    client = Client()
    client.force_login(user)
    url = reverse("providers:custom_attribute_add", kwargs={"organization_id": organization.id})
    data = {"content_type": Encounter.id, "name": "test custom field", "input_type": "date"}
    res = client.post(url, data)

    assert res.status_code == HTTPStatus.NOT_FOUND


def verify_creation(response, organization: Organization, attribute_name: str, option_value=None, option_label=None):
    assert response.status_code == HTTPStatus.FOUND
    assert isinstance(response, HttpResponseRedirect)
    assert f"/providers/organization/{organization.id}/fields" in response.url
    created_attribute = CustomAttribute.objects.filter(name=attribute_name).first()
    assert created_attribute
    if option_value or option_label:
        created_enum = CustomAttributeEnum.objects.filter(attribute_id=created_attribute.id).first()
        assert created_enum is not None
        if option_value:
            assert created_enum.value == option_value
        if option_label:
            assert created_enum.label == option_label


@pytest.mark.django_db
def test_create_custom_attribute(user: User, organization: Organization) -> None:
    assign_organization_role(organization, RoleName.OWNER, user)

    client = Client()
    client.force_login(user)
    url = reverse("providers:custom_attribute_add", kwargs={"organization_id": organization.id})
    data = {"content_type": Encounter.id, "name": "test custom field", "input_type": "date"}
    res = client.post(url, data)

    verify_creation(res, organization, "test custom field")


@pytest.mark.django_db
def test_create_custom_select_attribute(user: User, organization: Organization) -> None:
    assign_organization_role(organization, RoleName.OWNER, user)

    client = Client()
    client.force_login(user)
    url = reverse("providers:custom_attribute_add", kwargs={"organization_id": organization.id})
    data = {
        "content_type": Encounter.id,
        "name": "test select field",
        "input_type": "select",
        "enums-TOTAL_FORMS": 1,
        "enums-INITIAL_FORMS": 0,
        "enums-0-label": "select label",
        "enums-0-value": "test-value",
    }
    res = client.post(url, data)

    verify_creation(res, organization, "test select field", "test-value", "select label")


@pytest.mark.django_db
def test_custom_attribute_enum_value_autogenerated(user: User, organization: Organization) -> None:
    assign_organization_role(organization, RoleName.OWNER, user)

    client = Client()
    client.force_login(user)
    url = reverse("providers:custom_attribute_add", kwargs={"organization_id": organization.id})
    data = {
        "content_type": Encounter.id,
        "name": "test autogenerated field",
        "input_type": "select",
        "enums-TOTAL_FORMS": 1,
        "enums-INITIAL_FORMS": 0,
        "enums-0-label": "select label",
    }
    res = client.post(url, data)

    verify_creation(res, organization, "test autogenerated field", "select-label", "select label")


def test_create_custom_attribute_field_validation(user: User, organization: Organization) -> None:
    assign_organization_role(organization, RoleName.OWNER, user)
    current_attributes_count = CustomAttribute.objects.count()

    data = {"content_type": Encounter.id, "input_type": "Date"}

    client = Client()
    client.force_login(user)
    res = client.post(
        reverse(
            "providers:custom_attribute_add",
            kwargs={"organization_id": organization.id},
        ),
        data=data,
    )

    assert res.status_code == HTTPStatus.OK
    assert b"custom-attribute-form" in res.content
    # Should not create attribute
    assert CustomAttribute.objects.count() == current_attributes_count


@pytest.mark.django_db
def test_select_attribute_requires_one_option(user: User, organization: Organization) -> None:
    assign_organization_role(organization, RoleName.OWNER, user)

    client = Client()
    client.force_login(user)
    url = reverse("providers:custom_attribute_add", kwargs={"organization_id": organization.id})
    data = {
        "content_type": Encounter.id,
        "name": "broken select field",
        "input_type": "select",
        "enums-TOTAL_FORMS": 0,
        "enums-INITIAL_FORMS": 0,
    }
    res = client.post(url, data)

    assert res.status_code == HTTPStatus.OK
    assert b"custom-attribute-form" in res.content
    assert b"At least one option is required for Select/Multi-Select types. Please add options below." in res.content
    # Should not create attribute
    assert not CustomAttribute.objects.filter(name="broken select field").exists()

    data = {
        "content_type": Encounter.id,
        "name": "broken select field",
        "input_type": "select",
        "enums-TOTAL_FORMS": 1,
        "enums-INITIAL_FORMS": 0,
        "enums-0-label": "select label",
        "enums-0-value": "test-value",
        "enums-0-DELETE": "on",
    }
    res = client.post(url, data)

    assert res.status_code == HTTPStatus.OK
    assert b"custom-attribute-form" in res.content
    assert b"At least one option is required for Select/Multi-Select types. Please add options below." in res.content
    # Should not create attribute
    assert not CustomAttribute.objects.filter(name="broken select field").exists()


@pytest.mark.django_db
def test_delete_custom_attribute_with_confirmation(
    user: User, organization: Organization, encounter: Encounter
) -> None:
    """Test deleting a custom attribute with proper DELETE confirmation."""
    assign_organization_role(organization, RoleName.OWNER, user)

    # Create a custom attribute with enum values
    attribute = CustomAttribute.objects.create(
        organization=organization,
        content_type=ContentType.objects.get_for_model(Encounter),
        name="Priority",
        data_type=CustomAttribute.DataType.ENUM,
        is_multi=False,
    )
    enum_value = CustomAttributeEnum.objects.create(
        attribute=attribute,
        label="High Priority",
        value="high",
        color_code="FF0000",
    )

    # Create a value for this attribute on an encounter
    attr_value = CustomAttributeValue.objects.create(
        attribute=attribute,
        content_type=ContentType.objects.get_for_model(Encounter),
        object_id=encounter.id,
        value_enum=enum_value,
    )

    client = Client()
    client.force_login(user)
    url = reverse(
        "providers:custom_attribute_archive", kwargs={"organization_id": organization.id, "attribute_id": attribute.id}
    )

    # Post with correct confirmation
    data = {"confirmation": "DELETE"}
    res = client.post(url, data, headers={"HX-Request": True})

    # Should return 200 with HX-Redirect header
    assert res.status_code == HTTPStatus.OK
    assert "HX-Redirect" in res.headers

    # Attribute should be deleted
    assert not CustomAttribute.objects.filter(id=attribute.id).exists()

    # Enum values should be deleted (CASCADE)
    assert not CustomAttributeEnum.objects.filter(id=enum_value.id).exists()

    # Attribute values should be deleted (CASCADE)
    assert not CustomAttributeValue.objects.filter(id=attr_value.id).exists()


@pytest.mark.django_db
def test_delete_custom_attribute_wrong_confirmation(
    user: User, organization: Organization, encounter: Encounter
) -> None:
    """Test that deletion fails with incorrect confirmation text."""
    assign_organization_role(organization, RoleName.OWNER, user)

    # Create a custom attribute
    attribute = CustomAttribute.objects.create(
        organization=organization,
        content_type=ContentType.objects.get_for_model(Encounter),
        name="Test Field",
        data_type=CustomAttribute.DataType.DATE,
        is_multi=False,
    )

    client = Client()
    client.force_login(user)
    url = reverse(
        "providers:custom_attribute_archive", kwargs={"organization_id": organization.id, "attribute_id": attribute.id}
    )

    # Post with wrong confirmation
    data = {"confirmation": "delete"}  # lowercase, should fail
    res = client.post(url, data)

    # Should render the archive page with modal open (200), not redirect
    assert res.status_code == HTTPStatus.OK

    # Attribute should NOT be deleted
    assert CustomAttribute.objects.filter(id=attribute.id).exists()


@pytest.mark.django_db
def test_delete_custom_attribute_deny_access(user: User, organization: Organization, encounter: Encounter) -> None:
    """Test that users without permissions cannot delete custom attributes."""
    assign_organization_role(organization, RoleName.PATIENT, user)

    # Create a custom attribute
    attribute = CustomAttribute.objects.create(
        organization=organization,
        content_type=ContentType.objects.get_for_model(Encounter),
        name="Test Field",
        data_type=CustomAttribute.DataType.DATE,
        is_multi=False,
    )

    client = Client()
    client.force_login(user)
    url = reverse(
        "providers:custom_attribute_archive", kwargs={"organization_id": organization.id, "attribute_id": attribute.id}
    )

    data = {"confirmation": "DELETE"}
    res = client.post(url, data)

    # Should deny access
    assert res.status_code == HTTPStatus.NOT_FOUND

    # Attribute should NOT be deleted
    assert CustomAttribute.objects.filter(id=attribute.id).exists()
